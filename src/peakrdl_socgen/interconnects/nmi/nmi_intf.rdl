signal nmi_valid #(longint unsigned W=1){ 
    signalwidth=W; 
    activehigh = true;
    mosi;
    ss;

    desc = "Indicates that a valid transaction was put on the bus. Valid should stay valid until the ready signal is received.";
} ;

signal nmi_ready #(longint unsigned W=1){ 
    signalwidth=W; 
    activehigh = true;
    miso;

    desc = "Ready is driven by the slave, and acknowledges the handshake between master and slave.";
} ;

signal nmi_instr #(longint unsigned W=1){ 
    signalwidth=W; 
    activehigh = true;
    mosi;

    desc = "This signal is asserted on CPU instruction fetch to indicate instruction memory read, (OPTIONAL).";
} ;

signal nmi_addr #(longint unsigned W=32){ 
    signalwidth=W; 
    mosi;

    desc = "Address. This is the APB address bus. It can be up to 32 bits wide and is driven by the peripheral bus bridge unit.";
} ;

signal nmi_wdata #(longint unsigned W=32){ 
    signalwidth=W; 
    mosi;

    desc = "Write data, data to be written to the slave from master.";
} ;

signal nmi_rdata #(longint unsigned W=32){ 
    signalwidth=W; 
    miso;

    desc = "Read data, data read from the slave received by master.";
} ;

signal nmi_wstrb #(longint unsigned W=4){ 
    signalwidth=W; 
    mosi;

    desc = "Write data, data to be written to the slave from master.";
} ;

addrmap nmi_intf #(
    intf_t INTF = intf_t'{name:"nmi_intf", ADDR_WIDTH:32, DATA_WIDTH:32, prefix:"", modport:Modport::slave},
    longint unsigned N=1
    ){
    intf;
    intf_inst = INTF;
    n_array = N;

    nmi_valid #(.W(N))                nmi_valid;
    nmi_ready #(.W(N))                nmi_ready;
    nmi_instr #(.W(1))                nmi_instr;
    nmi_addr #(.W(INTF.ADDR_WIDTH))    nmi_addr;
    nmi_wdata #(.W(INTF.DATA_WIDTH))   nmi_wdata;
    nmi_rdata #(.W(N*INTF.DATA_WIDTH))   nmi_rdata;
    nmi_wstrb #(.W(INTF.DATA_WIDTH/8)) nmi_wstrb;

 reg {name = "dummy"; field {sw = r; hw = w;} dummy[1] = 0;} dummy;
};


addrmap nmi_tmr_intf #(
    intf_t INTF = intf_t'{name:"nmi_tmr_intf", ADDR_WIDTH:32, DATA_WIDTH:32, prefix:"", modport:Modport::slave}
    ){
    intf;
    intf_inst = INTF;

    nmi_valid #(.W(3))                  nmi_valid;
    nmi_ready #(.W(3))                  nmi_ready;
    nmi_instr #(.W(3))                  nmi_instr;
    nmi_addr #(.W(3*INTF.ADDR_WIDTH))    nmi_addr;
    nmi_wdata #(.W(3*INTF.DATA_WIDTH))   nmi_wdata;
    nmi_rdata #(.W(3*INTF.DATA_WIDTH))   nmi_rdata;
    nmi_wstrb #(.W(3*INTF.DATA_WIDTH/8)) nmi_wstrb;

 reg {name = "dummy"; field {sw = r; hw = w;} dummy[1] = 0;} dummy;
};

